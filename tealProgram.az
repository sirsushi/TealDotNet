#define Creator @ABCDEF
#define Escrow @ABCDEF

def Approval() {
	if (Txn.Type != ApplicationCall)
		return false;

	switch txn.OnComplete {
		case NoOp {
			ExecuteNoOp();
		}
		case OptIn {
			ExecuteOptIn();
		}
		case CloseOut {
			ExecuteCloseOut();
		}
		case UpdateApplication {
			ExecuteUpdateApplication();
		}
		case DeleteApplication {
			ExecuteDeleteApplication();
		}
	}
}

def CalculateGains(ticketCount) {
	return ticketCount * 1000000 * 99 / 100;
}

def ExecuteNoOp() {
	if (Txn.Sender == Creator) {
		switch (args[0]) {
			case "open" {
				if (global.state.open) throw "Lotery already opened";
				global.state.open = true;
				global.state.nextDrawIndex++;
				global.state.nextDrawTicketCount = 0;
			}
			case "close" {
				if (!global.state.open) throw "Lotery already closed";
				global.state.open = false;
			}
			case "draw" {
				if (global.state.open) throw "Close lotery before draw";
				global.state.draw = [0, 0, 0, 0, 0];
				global.state.currentDrawIndex = global.state.nextDrawIndex;
				global.state.currentDrawPot = CalculateGains(global.state.nextDrawTicketCount);
				fees = global.state.nextDrawTicketCount * 1000000 - CalculateGains(global.state.nextDrawTicketCount);
				SendAlgo(fees, Creator, Escrow);
			}
			case "getTicket", "checkGains", "claimGains" {
				throw "Can't execute this function";
			}
			default {
				throw "Wrong function executed";
			}
		}
	}
	else {
		switch (args[0]) {
			case "getTicket" {
				if (Txn.Sender.state.haveTicket) throw "Already have ticket";
				Txn.Sender.state.haveTicket = true;
				Txn.Sender.state.ticket = args[1];
				Txn.Sender.state.ticketDrawIndex = global.state.nextDrawIndex;
				global.state.nextDrawTicketCount++;
			}
			case "checkGains" {}
			case "claimGains" {}
			case "open", "close", "draw" {
				throw "Can't execute this function";
			}
			default {
				throw "Wrong function executed";
			}
		}
	}
}

def ExecuteOptIn() {
	exit true;
}

def ExecuteCloseOut() {
	exit true;
}

def ExecuteUpdateApplication() {
	exit txt.sender == Creator;
}

def ExecuteDeleteApplication() {
	exit txt.sender == Creator;
}

def ClearState() {
	ExecuteCloseOut();
}